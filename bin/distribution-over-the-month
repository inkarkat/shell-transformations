#!/bin/bash

: ${DISTRIBUTIONOVERTHEMONTH_BORDERS=⎡ ⎤ ⎣ ⎦}
typeset -a borders=()
[ -n "$DISTRIBUTIONOVERTHEMONTH_BORDERS" ] && IFS='' read -r -d '' -a borders <<<"${DISTRIBUTIONOVERTHEMONTH_BORDERS// /}"
[ ${#borders[@]} -gt 0 ] && borders[-1]="${borders[-1]%$'\n'}"

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf "Usage: echo -e '2021-12-31 11:01\\\\n2022-01-11 12:00\\\\n...'| [DISTRIBUTIONOVERTHEMONTH_BORDERS='/ \ L J'] [DISTRIBUTIONOVERTHEMONTH_LEGEND_LENGTH=N] %q %s\\n" "$(basename "$1")" '[--no-footer] [--graph-legend TEXT] [--graph-field N] [--footer-legend TEXT] [--footer-field N] [-F|--field-separator FS] [--day-field N] [--slots-per-day N [--hour-field M]] [--split-graph-field N [--split-graph-field ...]] [SPARK-ARGS ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Print the distribution of the number of dates (and optionally times of day) that
fall into a certain slot (1 day by default) over the month; i.e. from the first
until the last day of the month. Requires the day of the month in the third
column of the data (after year and month); anything after that is ignored.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --no-footer		Omit the footer that shows the hours.
    --graph-legend TEXT	Add TEXT in front of the distribution. This will also be
			the fallback text if no field value is found.
    --graph-field N	Add text captured from the first non-empty column N of
			the input data in front of the distribution.
    --footer-legend TEXT
			Add TEXT in front of the footer. If --no-footer, this
			will be put after the graph legend instead. This will
			also be the fallback text if no field value is found.
    --footer-field N	Add text captured from the first non-empty column N of
			the input data in front of the footer. If --no-footer,
			this will be put after the graph legend instead.
    --field-separator|-F FS
			Use FS for splitting the data into columns (instead of
			the default whitespace + [:_/-]).
    --day-field N	Take the day of the month from column N instead of 3.
    --slots-per-day N	Divide each day into N slots (comprising 24 / N
			hours); default is 1 slot per day. The hour that is
			required for more than one slot is taken from the fourth
			column.
    --hour-field M	Take the hour of the day from column M instead of 4.
    --split-graph-field N
			Whenever the non-empty value of column N changes, start
			a new graph. If you want to graph every month
			separately, pass the year and month columns here.
HELPTEXT
}

typeset -a sparkArgs=()
graphLegendText=
graphFieldNr=
footerLegendText=
footerFieldNr=
separator='[[:space:]:_/-]'
dayFieldNr=3
hourFieldNr=4
isFooter=t
slotNum=1
typeset -a splitFieldNrs=()
typeset -a sparkArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--no-footer)	shift; isFooter=;;
	--graph-legend)	shift; graphLegendText="$1"; shift;;
	--graph-field)	shift; graphFieldNr="$1"; shift;;
	--footer-legend)
			shift; footerLegendText="$1"; shift;;
	--footer-field)	shift; footerFieldNr="$1"; shift;;
	--field-separator|-F)
			shift; separator="${1:?}"; shift;;
	--slots-per-day)
			shift; slotNum="$1"; shift;;
	--day-field)    shift; dayFieldNr="${1:?}"; shift;;
	--hour-field)   shift; hourFieldNr="${1:?}"; shift;;
	--split-graph-field)
			shift; splitFieldNrs+=("$1"); shift;;
	--)		sparkArgs+=("$1"); shift; break;;
	*)		sparkArgs+=("$1"); shift;;
    esac
done

IFS=$'\n'
tally()
{
    awk \
	--field-separator "$separator" \
	-v "graphFieldNr=$graphFieldNr" \
	-v "footerFieldNr=$footerFieldNr" \
	-v "dayFieldNr=$dayFieldNr" \
	-v "hourFieldNr=$hourFieldNr" \
	-v "slotNum=$slotNum" \
	-v "splitFieldNrList=${splitFieldNrs[*]//\\/\\\\}" \
'
BEGIN {
    splitFieldNrNum = split(splitFieldNrList, splitFieldNrs, "\n")
}
function printSection(      h, result, s)
{
    print graphLegend; graphLegend = ""
    print footerLegend; footerLegend = ""

    if (slotNum >= 2) {
	for (h = 1; h <= 31; ++h) {
	    printf("%-" slotNum "." slotNum "s", h)
	}
    } else {
	for (h = 1; h < 31; h += 3) {
	    printf("%-3.3s", h)
	}
	printf(" ") # Already printed 3 * 10 characters - need one more to make up 31 cells.
    }
    printf "\n"

    result = render(count[0])
    for (s = 1; s < 31 * slotNum; ++s) {
	result = result "," render(count[s])
    }
    print result; delete count
}
function render(v)
{
    return (v == "" ? " " : v)
}
{
    for (i in splitFieldNrs) {
	sf = splitFieldNrs[i]
	if ($sf != "" && watchedFields[sf] != "" && watchedFields[sf] != $sf) {
	    printSection()

	    delete watchedFields
	    for (sf in splitFieldNrs) {
		if ($sf != "") watchedFields[sf] = $sf
	    }
	    break
	} else if (watchedFields[sf] == "" && $sf != "") {
	    watchedFields[sf] = $sf
	}
    }

    if (graphFieldNr != "" && graphLegend == "") graphLegend = $graphFieldNr
    if (footerFieldNr != "" && footerLegend == "") footerLegend = $footerFieldNr

    slot = int((int($dayFieldNr) - 1) * slotNum + (slotNum > 1 ? int($hourFieldNr) * slotNum / 24 : 0))
    count[slot] += 1
}
END {
    printSection()
}
'
}

printDistribution()
{
    while :
    do
	# Each section consists of 4 lines:
	# - legend for graph
	# - legend for footer
	# - footer
	# - comma-separated data
	local graphLegendFromData; IFS=$'\n' read -r graphLegendFromData || break
	local graphLegend="${graphLegendFromData:-$graphLegendText}"
	local footerLegendFromData; IFS=$'\n' read -r footerLegendFromData || break
	local footerLegend="${footerLegendFromData:-$footerLegendText}"
	local footer; IFS=$'\n' read -r footer || break
	local data; IFS=$'\n' read -r data || break

	local renderedDistribution; renderedDistribution="$(printf '%s\n' "$data" | spark --min 0 "${sparkArgs[@]}")"

	local legendWidth=$DISTRIBUTIONOVERTHEMONTH_LEGEND_LENGTH

	if [ "$isFooter" ]; then
	    if [ -z "$legendWidth" ]; then
		legendWidth=$((${#graphLegend} > ${#footerLegend} ? ${#graphLegend} : ${#footerLegend}))
		[ -n "${borders[0]}" ] || let legendWidth+=1
	    fi

	    printf "%-${legendWidth}.${legendWidth}s%s%s%s\\n" "$graphLegend" "${borders[0]}" "$renderedDistribution" "${borders[1]}"
	    printf "%-${legendWidth}.${legendWidth}s%s%s%s\\n" "$footerLegend" "${borders[2]}" "$footer" "${borders[3]}"
	else
	    local completeLegend="$graphLegend"; [ -n "$graphLegend" -a -n "$footerLegend" ] && completeLegend="${completeLegend} "; completeLegend="${completeLegend}${footerLegend}"
	    printf "%${legendWidth:+-}${legendWidth}${legendWidth:+.}${legendWidth}s%s\\n" "$completeLegend" "$renderedDistribution"
	fi
    done
}

tally | printDistribution
